{"version":3,"file":"static/js/238.37cc24a6.chunk.js","mappings":"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","sources":["../node_modules/geotiff/dist-module/predictor.js","../node_modules/geotiff/dist-module/compression/basedecoder.js","../node_modules/geotiff/dist-module/compression/webimage.js"],"sourcesContent":["function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n","import { applyPredictor } from '../predictor.js';\n\nexport default class BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return applyPredictor(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n","import BaseDecoder from './basedecoder.js';\n\n/**\n * class WebImageDecoder\n *\n * This decoder uses the browsers image decoding facilities to read image\n * formats like WebP when supported.\n */\nexport default class WebImageDecoder extends BaseDecoder {\n  constructor() {\n    super();\n    if (typeof createImageBitmap === 'undefined') {\n      throw new Error('Cannot decode WebImage as `createImageBitmap` is not available');\n    } else if (typeof document === 'undefined' && typeof OffscreenCanvas === 'undefined') {\n      throw new Error('Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available');\n    }\n  }\n\n  async decode(fileDirectory, buffer) {\n    const blob = new Blob([buffer]);\n    const imageBitmap = await createImageBitmap(blob);\n\n    let canvas;\n    if (typeof document !== 'undefined') {\n      canvas = document.createElement('canvas');\n      canvas.width = imageBitmap.width;\n      canvas.height = imageBitmap.height;\n    } else {\n      canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n    }\n\n    const ctx = canvas.getContext('2d');\n    ctx.drawImage(imageBitmap, 0, 0);\n\n    // TODO: check how many samples per pixel we have, and return RGB/RGBA accordingly\n    // it seems like GDAL always encodes via RGBA which does not require a translation\n\n    return ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height).data.buffer;\n  }\n}\n"],"names":["decodeRowAcc","row","stride","length","offset","i","decodeRowFloatingPoint","bytesPerSample","index","count","wc","copy","slice","b","applyPredictor","block","predictor","width","height","bitsPerSample","planarConfiguration","Error","byteLength","Uint8Array","Uint16Array","Uint32Array","concat","BaseDecoder","_classCallCheck","_createClass","key","value","_decode","_asyncToGenerator","_regeneratorRuntime","mark","_callee","fileDirectory","buffer","decoded","isTiled","tileWidth","tileHeight","wrap","_context","prev","next","this","decodeBlock","sent","Predictor","StripOffsets","TileWidth","ImageWidth","TileLength","RowsPerStrip","ImageLength","abrupt","BitsPerSample","PlanarConfiguration","stop","_x","_x2","apply","arguments","WebImageDecoder","_BaseDecoder","_inherits","_super","_createSuper","_this","call","createImageBitmap","document","OffscreenCanvas","blob","imageBitmap","canvas","ctx","Blob","createElement","getContext","drawImage","getImageData","data"],"sourceRoot":""}