{"version":3,"file":"static/js/75.311c4876.chunk.js","mappings":"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","sources":["../node_modules/geotiff/dist-module/predictor.js","../node_modules/geotiff/dist-module/compression/basedecoder.js","../node_modules/geotiff/dist-module/compression/lzw.js"],"sourcesContent":["function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n","import { applyPredictor } from '../predictor.js';\n\nexport default class BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return applyPredictor(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n","import BaseDecoder from './basedecoder.js';\n\nconst MIN_BITS = 9;\nconst CLEAR_CODE = 256; // clear code\nconst EOI_CODE = 257; // end of information\nconst MAX_BYTELENGTH = 12;\n\nfunction getByte(array, position, length) {\n  const d = position % 8;\n  const a = Math.floor(position / 8);\n  const de = 8 - d;\n  const ef = (position + length) - ((a + 1) * 8);\n  let fg = (8 * (a + 2)) - (position + length);\n  const dg = ((a + 2) * 8) - position;\n  fg = Math.max(0, fg);\n  if (a >= array.length) {\n    console.warn('ran off the end of the buffer before finding EOI_CODE (end on input code)');\n    return EOI_CODE;\n  }\n  let chunk1 = array[a] & ((2 ** (8 - d)) - 1);\n  chunk1 <<= (length - de);\n  let chunks = chunk1;\n  if (a + 1 < array.length) {\n    let chunk2 = array[a + 1] >>> fg;\n    chunk2 <<= Math.max(0, (length - dg));\n    chunks += chunk2;\n  }\n  if (ef > 8 && a + 2 < array.length) {\n    const hi = ((a + 3) * 8) - (position + length);\n    const chunk3 = array[a + 2] >>> hi;\n    chunks += chunk3;\n  }\n  return chunks;\n}\n\nfunction appendReversed(dest, source) {\n  for (let i = source.length - 1; i >= 0; i--) {\n    dest.push(source[i]);\n  }\n  return dest;\n}\n\nfunction decompress(input) {\n  const dictionaryIndex = new Uint16Array(4093);\n  const dictionaryChar = new Uint8Array(4093);\n  for (let i = 0; i <= 257; i++) {\n    dictionaryIndex[i] = 4096;\n    dictionaryChar[i] = i;\n  }\n  let dictionaryLength = 258;\n  let byteLength = MIN_BITS;\n  let position = 0;\n\n  function initDictionary() {\n    dictionaryLength = 258;\n    byteLength = MIN_BITS;\n  }\n  function getNext(array) {\n    const byte = getByte(array, position, byteLength);\n    position += byteLength;\n    return byte;\n  }\n  function addToDictionary(i, c) {\n    dictionaryChar[dictionaryLength] = c;\n    dictionaryIndex[dictionaryLength] = i;\n    dictionaryLength++;\n    return dictionaryLength - 1;\n  }\n  function getDictionaryReversed(n) {\n    const rev = [];\n    for (let i = n; i !== 4096; i = dictionaryIndex[i]) {\n      rev.push(dictionaryChar[i]);\n    }\n    return rev;\n  }\n\n  const result = [];\n  initDictionary();\n  const array = new Uint8Array(input);\n  let code = getNext(array);\n  let oldCode;\n  while (code !== EOI_CODE) {\n    if (code === CLEAR_CODE) {\n      initDictionary();\n      code = getNext(array);\n      while (code === CLEAR_CODE) {\n        code = getNext(array);\n      }\n\n      if (code === EOI_CODE) {\n        break;\n      } else if (code > CLEAR_CODE) {\n        throw new Error(`corrupted code at scanline ${code}`);\n      } else {\n        const val = getDictionaryReversed(code);\n        appendReversed(result, val);\n        oldCode = code;\n      }\n    } else if (code < dictionaryLength) {\n      const val = getDictionaryReversed(code);\n      appendReversed(result, val);\n      addToDictionary(oldCode, val[val.length - 1]);\n      oldCode = code;\n    } else {\n      const oldVal = getDictionaryReversed(oldCode);\n      if (!oldVal) {\n        throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);\n      }\n      appendReversed(result, oldVal);\n      result.push(oldVal[oldVal.length - 1]);\n      addToDictionary(oldCode, oldVal[oldVal.length - 1]);\n      oldCode = code;\n    }\n\n    if (dictionaryLength + 1 >= (2 ** byteLength)) {\n      if (byteLength === MAX_BYTELENGTH) {\n        oldCode = undefined;\n      } else {\n        byteLength++;\n      }\n    }\n    code = getNext(array);\n  }\n  return new Uint8Array(result);\n}\n\nexport default class LZWDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    return decompress(buffer, false).buffer;\n  }\n}\n"],"names":["decodeRowAcc","row","stride","length","offset","i","decodeRowFloatingPoint","bytesPerSample","index","count","wc","copy","slice","b","applyPredictor","block","predictor","width","height","bitsPerSample","planarConfiguration","Error","byteLength","Uint8Array","Uint16Array","Uint32Array","concat","BaseDecoder","_classCallCheck","_createClass","key","value","_decode","_asyncToGenerator","_regeneratorRuntime","mark","_callee","fileDirectory","buffer","decoded","isTiled","tileWidth","tileHeight","wrap","_context","prev","next","this","decodeBlock","sent","Predictor","StripOffsets","TileWidth","ImageWidth","TileLength","RowsPerStrip","ImageLength","abrupt","BitsPerSample","PlanarConfiguration","stop","_x","_x2","apply","arguments","EOI_CODE","appendReversed","dest","source","push","decompress","input","dictionaryIndex","dictionaryChar","dictionaryLength","position","initDictionary","getNext","array","byte","d","a","Math","floor","de","ef","fg","dg","max","console","warn","chunk1","pow","chunks","chunk2","hi","getByte","addToDictionary","c","getDictionaryReversed","n","rev","result","oldCode","code","val","oldVal","undefined","LZWDecoder","_BaseDecoder","_inherits","_super","_createSuper"],"sourceRoot":""}